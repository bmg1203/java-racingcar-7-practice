# java-calculator-precourse

> ### [노션 : 프로젝트 정리](https://grand-calcium-138.notion.site/2-1288d7f5b23380158fb0ce75ae1dd4ac?pvs=4)
---

## 브랜치 네이밍 규칙 
> <브랜치 종류> / <설명>

### 예시
> feature/login
- 유저 로그인 기능 개발 브랜치
> chore/gredle
- 그래들 설정 추가


#### 이번 미션 초기 5시간 개발에는 -> 브랜치를 사용 안해볼 것
- 브랜치 사용에 대한 토론을 나눠본 결과
  - 브랜치 기능을 다양하게 활용하려면
    - 한 기능에 대해서 여러 접근 방식을 diff 로 비교
    - 여러 개발자가 한 프로젝트를 개발 할 경우  
      

- 미션 특성을 고려해봤을때
  - 짧은 시간 내에 프로토 타입을 개발해야 하는 것으로 이해
  - 그 이후 여러 기능적 추가 고려해 볼것

---

## 커밋 네이밍 및 작성 규칙 
> ### [GIT 활용하기](https://grand-calcium-138.notion.site/Git-1298d7f5b23380648b3df759e88d6f80?pvs=4)

> 타이틀 : <커밋 종류> : <기능 개발 내용>  
> 본문 : 한줄 띄우고 본문 작성

### 예시
> feat: 로그인 기능 추가  
> - jwt 기능 구현
> - 로그인시 아이디 유효성 검사 기능 구현
> - 로그인시 비밀번호 유효성 검사 기능 구현

--- 

# 자동차 경주 기능 명세

> **입력 수 만큼 경주 이후 우승자 출력**

## 예시  

**입력**
  - 이름  
    `pobi,woni,jun`
 
  
  - 시도 횟수  
    `5`
  
**출력**
  - 차수별 실행 결과
```angular2html
    pobi : --   
    woni : ----  
    jun : ---  
```
- 단독 우승자 안내 문구
```angular2html
최종 우승자 : pobi 
```
- 공동 우승자 안내 문구
```angular2html
최종 우승자 : pobi, jun
```

---

## 기능 요구 사항 정리

1. [README.md](http://README.md) 작성
2. 다음 순서 대로, 테스트 코드를 작성한다. (TDD)
3. 사용자에게 어떤 행위를 할지 알려 준다.
4. 사용자에게 입력을 받는다.
5. 입력의 유효성을 검증한다.
6. 자동차를 만든다.
7. 입력 값 만큼 경주 실행하고 출력한다. 
8. 우승자를 출력한다.
9. 입력 예외 사항을 늘린다.

---

## 기능 목록

| **기능 목록**                     | **구현**                                         |
|-------------------------------|------------------------------------------------|
| 다음 순서 대로, 테스트 코드를 작성한다. (TDD) | 테스트 코드 작성 (초기엔 모두 실패해야 함)                      |
| 사용자에게 어떤 행위를 할지 알려준다.         | `view 클래스` 구현해서 → 사용자에게 어떤 입력을 해야 하는지 알려준다.    |
| 사용자에게 입력을 받는다.              | 입력을 받는 기능를 만들어 입력을 받는다.                        |
| 입력의 유효성을 검증한다.                | 이 단계에서는 입력이 `숫자`, `양수`, `정수` 인지만을 확인한다.        |
| 입력값 대로 자동차를 만든다.                | 자동차를 만들기 위한 기능 구현                              |
| 자동차 경주 실행 → 경주 결과를 출력한다.              | 경주 결과를 n 번 출력 하기 위한 기능 구현                      |
| 우승자를 출력한다.                 | 경주 마지막 이후에 결과 값을 추산해서 → 알맞은 출력을 한다.            |
| 입력 예외 사항을 늘린다.           | 여러 예외 사항을 늘린다. 예외사항을 → 사용자에게 알려준다.|
| 테스트 코드 고도화           | 테스트 코드 추가하고, 고도화 한다. |

---

## 기능 구현 계획

--- 

### TDD (Test-Driven Development) 적용

### 초기
- 5시간을 기준으로 개발
- 가장 기초 기능만을 통과하도록 설정 할 것

### 리펙터링
- **여러 기능적 한계를 추가할 것**
  - 이모지에 대한 처리
  - "as v" 와 같은 값에 대한 처리
  - 이름 중복을 허용하지 않는 처리
---

### 1. **View 클래스**
- 사용자에게 어떤 값을 입력해야하는지를 알려주는 레이어 

### 2. **Service 클래스**
- `Car` 객체의 로직을 활용하는 클래스
- 비즈니스 로직를 다룸

### 3. **Controller 클래스 활용**
- `Service` 클래스에 정의된 로직을 실행 시킴

---

## 테스트 코드 작성

### **테스트 토픽**
- 초기 개발
  - 지시문 출력
  - 입력 값 받기
  - 입력 유효성 검증
  - 경주 자동차 생성 검증
  - 경주 실행 및 출력
  - 우승자 출력
    

- 리펙토링
  - 에러 핸들링
  - 구조 개선
  - 로직 효율성 증가

---

1. [README.md](http://README.md) 작성
2. 다음 순서 대로, 테스트 코드를 작성한다. (TDD)
3. 사용자에게 어떤 행위를 할지 알려 준다.
4. 사용자에게 입력을 받는다.
5. 입력의 유효성을 검증한다.
6. 자동차를 만든다.
7. 입력 값 만큼 경주 실행하고 출력한다.
8. 우승자를 출력한다.
9. 입력 예외 사항을 늘린다.



## 기능별 상세 설계

### 1. **지시문 출력**
- **토픽**: 지시문 출력 기능 개발
- **스토리**:
    - 어떤 식의 인풋을 해야하는지를 출력한다.

---

### 2. **입력 받기 기능**
- **토픽**
    - 입력 받기 기능 개발
- **스토리**
    - 사용자에게 입력을 받는다.


---

### 3. **입력 유효성 검즘**
- **토픽**
    - 입력 유효성 검즘 기능 개발
- **스토리**
    - 이름을 , 로 구분해서 받는다.
    - 공백이 없는지 확인
    - 길이가 5이하인지 확인
    - n이 양수인지 확인

#### **유효성 검증 기준**
**잘못된 입력 처리**:
  - 개발 초기
    - 공백을 무시함
    - 이름이 길이는 5이하
    - n입력이 양수가 아닌경우
    - 이름 주변 공백은 허용
      -  ex)  " 123 " -> 3글자
  - 리펙터링시
    - 이모티콘에 대해?
    - 이름이 같은 경우
    - "abc d" -> 허용

---

### 4. **경주차 객체 생성**
- **토픽**
    - 경주차 객체 생성
- **스토리**
    - 이름 저장 기능
    - 움직임 기능
---

### 5. **경주 진행 기능**
- **토픽**
    - 경주 진행 기능 개발
- **스토리**
    - 경주 진행 상황을 n 번에 걸쳐 출력

---

### 6. **우승자 출력**
- **토픽**
  - 우승자 출력 기능 개발
- **스토리**
  - 우승자 판단
  - 단독 우승자일때 출력 기능
  - 공동 우승자일때 출력 기능

---
### 7. **리펙토링 진행**
- 개발하면서 부족했던 부분 개발
  - 예외 사항
  - 코드 로직
  - 구조 


---

# 개발 일지 : 고민들

## 피드백
- 피드백을 통해 스스로 공부하고 생각할 시간이 있어서 좋았다.
- 제공된 피드백 영상이 특히 유익했다.

  - **내 개발 방식**과 **강의의 개발 방식**의 차이를 확인할 수 있었다.

    #### 내 개발 방식
    - 함수나 기능을 생각하고, 이를 최대한 나누어 구현
    - **단점:**
      - 자연스러운 흐름이 생기지 않음
      - 오류 발생 시 어느 부분에서 발생했는지 확인하기 어려움

    #### 강의의 개발 방식
    - **작은 요구사항부터** 하나씩 구현 시작
    - **개발의 분기점**에서 고민 후 적용하고, 테스트로 확인
    - 아주 기본적인 것부터 점차 넓혀가는 방식으로, **기초 기능을 우선적으로 구현한 뒤 리팩토링**을 계획

---

## 내가 브랜치를 파서 코드를 관리하는게 과연 정답일까?

### 브랜치를 활용하는 이유
- **동시 작업 시 Conflict 감소**: 같은 프로젝트에서 여러 사람이 작업할 때 충돌을 방지
- **코드 유효성 검증**: 풀 리퀘스트를 통해 코드 리뷰와 검증 수행

  - 그러나 혼자 작업하는데도 브랜치를 사용할 필요가 있을까?
    - 기능 개발의 종류를 알기 위한 것이라면 **커밋 메시지로도 충분**할 수 있음

### 그럼에도 불구하고 브랜치를 사용하는 이유
- **독립적인 작업 공간** 제공
  - 특정 기능에 집중하다가 다른 기능 작업이 필요할 때 Conflict 없이 브랜치 변경 가능
- **커밋 메시지로 충분할까?**
  - 커밋 메시지는 세부 기능 설명에 적합하지만, **전체 흐름 파악에는 브랜치가 유리**

---

## 테스트를 위한 Mock 클래스 활용

- 기존에는 `camp.nextstep.edu.missionutils.Randoms`를 직접 사용해 0~9 난수를 생성
  - 랜덤 값으로 인해 **테스트 결과 지정이 어려움**

### 해결 방법
1. **MockRandomGenerator 구현**
  - `RandomGenerator` 인터페이스를 만들고 `MockRandomGenerator`를 구현하여 랜덤 값 주입 가능
2. **Wrapper 클래스 활용**
  - `camp.nextstep.edu.missionutils.Randoms`를 사용하는 Wrapper 클래스 사용
3. **의존성 주입을 통해 RacingCar 객체가 Randoms에 직접 의존하지 않도록 수정**

---

## 객체지향 설계를 할때는 클래스에서 최대한 인자를 받아야 할까?

- 테스트 코드를 작성하면서 
  - 그 클래스 안에 정의된 필드가 다른 메서드에 의해 정해지면
  - 의존성이 생김 → **단일 책임 원칙(SRP) 위반**을 확인 
  
    
- 인자 처리를 해야 하는 이유
  - 클래스 내 필드가 다른 메서드에 의존하면 **단일 책임 원칙(SRP)** 위반 가능성
  - 독립적인 유닛 테스트가 용이
  - 유지보수성 향상
  - 메서드가 인자를 받으면 다양한 상황에서 재사용 가능

---

## 테스트 코드에서 출력 값을 지정하는 방법

1. **예상 출력 값을 미리 정의**
    ```java
    String expectResult = "최종 우승자 : fobi\n";
    ```
2. **ByteArrayOutputStream 객체 생성**
  - 출력 데이터를 바이트로 저장
    ```java
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    ```
3. **System.out 설정 변경**
  - `System.setOut`으로 출력 스트림을 `outputStream`에 저장되도록 설정
    ```java
    System.setOut(new PrintStream(outputStream));
    ```
4. **결과 비교**
  - `outputStream`의 값을 문자열로 변환 후 예상 값과 비교
    ```java
    String actualOutput = outputStream.toString();
    assertEquals(expectResult, actualOutput);
    ```

---

## 리팩터링 일지

1. **객체 지향적인 코드 구성**
  - 필드 사용 최소화, 메서드는 인자를 받아 로직을 처리하도록 구성

2. **Service 및 유틸 클래스의 분산**
  - 컨트롤러에 생성자로 사용되던 많은 Service와 유틸 클래스를 분산

3. **상수 관리**
  - 자주 사용되는 상수는 **별도의 클래스**로 관리하여 가독성과 유지보수성 향상

4. **함수 재사용**
  - `runRound`와 같은 함수를 만들어서 동일한 로직 재사용 가능하도록 개선

5. **테스트 코드와 리팩터링 병행**
  - 리팩터링 과정에서 로직 유지 확인을 위해 테스트 코드도 수정하고, 최종 확인 단계에서 테스트 수행

6. **중복 이름 처리**
  - 중복되는 이름이 있을 경우 에러 처리 추가

