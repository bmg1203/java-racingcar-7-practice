# java-racingcar-precourse
# 초간단 자동차 경주 게임

## 기능 목록

- [x] 문자열(경주할 자동차 이름) 입력 
  - [x] 자동차 이름은 5자 이하만 가능 
  - [x] 사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시킨 후 애플리케이션은 종료
- [x] 입력된 문자열을 쉼표 기준으로 구분
- [x] 문자열(시도 횟수)를 입력
  - [x] 사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시킨 후 애플리케이션은 종료
- [x] 각 자동차 별 무작위 값(0에서 9사이) 선정
  - [x] 무작위 값이 4이상일 경우 전진, 미만일 경우 멈춤
- [x] 해당 차수별 실행 결과 출력
- [x] 시도 횟수에 도달할 때까지 진행
- [x] 도달 했을 시, 가장 많이 움직인 자동차를 우승자로 선정
  - [x] 2명 이상일 경우, 쉼표(,)를 이용하여 구분

---

## 해당 방식으로 구현하게된 이유

### Q. 왜 생성한 객체를 모아서 쓰지 않고, 분리해서 썼나요?
A. 코드의 흐름을 보여주기 위해서 미리 생성하지 않아도 되는 객체는 생성하지 않고 흐름에 맞게 생성

### Q. 클래스 및 패키지 구분을 어떻게 하신건가요?
A. 한가지 통용 단어를 패키지로,해당 단어로 패키지를, 단어 + 단어로 구체화 시킨 단어의 조합을 클래스로 생성

### Q. 코드 리뷰를 위해서는 코드를 어떤 순서로 봐야할까요?
A. 전체적인 기능파악 - 테스트코드, 코드 흐름 - Application 클래스부터 차례대로

### Q. 함수 작명을 어떻게 하셨나요?
A. 최대한 동사 + 명사 위주로 어떤 행동을 하는지 보여주려고 네이밍 

### Q. 왜 처음에 Map으로 ScoreList를 만들다가, 최종 점수는 왜 List로 반환하였나요?
A. 점수가 늘어난 자동차에게 "-"를 더해준다를 직관적으로 보이기 위해 Map으로 만들고, 점수 최대값을 구하기 위해 List로 변환. 더 좋은 방법이 있다면 Comment로 알려주세요!

### Q. Map을 쓰면 입력한 순서대로 자동차 이름이 출력되지 않는데, 이 부분을 배제하신 이유가 있나요?
A. 일단 문제에서 순서대로 자동차 이름이 출력되어야 한다는 조건이 없었고, 이 순서를 지키는 것이 경기를 뛰는데 중요한 기준이 아니라고 판단하여서 배제

### Q. 자동차 경주 횟수를 다음과 같이 제한한 이유는 무엇인가요?
A. 테스트나 시뮬레이션 목적이라도 1000바퀴 이상은 과도하다고 판단, 너무 많은 횟수는 프로그램 실행 시간과 사용자 경험에 부정적이라고 판단하였기 때문

---

## 2주차 프리코스 과제 구현 유의사항

### 1. 1주차 피드백 내용에 따라서 commit을 진행한다.

1. 주어진 요구사항을 차례대로 빠르게 구현한다.
2. 시간이 남으면 예외 케이스들을 추가해서 반영 및 구현한다.
3. 클린코드, 객체 지향 코드를 구현한다.

### 2. 1주차 프리코스 코드리뷰 중 지적받았던 부분을 모두 반영한다.

- [refactor] 메서드 명은 동사 + 명사로 짓는다.
- [docs] 구현한 내용을 빠짐없이 README.md 파일에 적는다.
    - 어떠한 이유로 다음과 같은 기능을 만들었는가?
- [refactor] 자바 메서드 순서를 고려한다.
    1. public 주석
    2. 클래스
    3. 정적 변수: public -> protected -> private
    4. 인스턴스 변수: public -> protected -> private
    5. 생성자
    6. 정적 메소드: static 메소드
    7. 메소드: 접근자 기준으로 작성하지 않고, 기능 및 역할별로 분류하여 기능을 구현한다.
    8. 스탠다드 메소드: toString, equals, hashcode와 같은 메소드
    9. getter, setter 메소드: 클래스의 밑 부분에 위치
- [refactor] 생성자로 객체를 주입받는다.
- [refactor] 원시값을 포장한다.
  - String age과 같이 단순 타입이 담긴 원시값을 사용하는 것이 아닌, age라는 새로운 클래스를 만들어 캡슐화
  - 컴파일 시점에 타입 안전성 보장
- [refactor] 객체 지향적 코딩을 준수한다.
  - ex-1) 계산기 클래스에서 구분자를 위한 메서드가 너무 많다 -> 구분자 클래스를 만들어 클래스 분리
  - ex-2) exception package: 예외 처리 관련 클래스들, parser: 입력값 처리를 담당하는 클래스들
- [refactor] 문제에서 주어진 고정 변수값은 상수화 시켜서 나중에 변수값이 변해도 유지보수가 쉽도록 만들기

### 3. 1주차 공통 피드백을 최대한 반영한다.

- 요구 사항을 정확하게 준수한다.
  - 과제 진행 요구 사항, 기능 요구 사항, 프로그래밍 요구 사항을 모두 충족하였는지 다시 한번 확인한다.
- 기본적인 Git 명령어를 숙지한다.
- Git으로 관리할 자원을 고려한다.
- 커밋 메시지를 의미 있게 작성한다.
  - 제목과 본문을 한 줄 띄워 분리하기
  - 제목은 영문 기준 50자 이내
  - 제목 첫글자를 대문자로
  - 제목 끝에 . 금지
  - 제목은 명령조로
  - 본문은 영문 기준 72자마다 줄 바꾸기
  - 본문은 어떻게 보다 무엇을, 왜에 맞춰 작성하기
- 커밋 메시지에 이슈 또는 풀 리퀘스트 번호를 포함하지 않는다.
- 풀 리퀘스트를 만든 후에는 닫지 말고 추가 커밋을 한다.
- 오류를 찾을 때 출력 함수 대신 디버거를 사용한다.
- 이름을 통해 의도를 드러낸다.
- 축약하지 않는다.
- 공백도 코딩 컨벤션이다.
- 공백 라인을 의미 있게 사용한다.
- 스페이스와 탭을 혼용하지 않는다.
- 의미 없는 주석을 달지 않는다.
- 코드 포매팅을 사용한다.
- Java에서 제공하는 API를 적극 활용한다.
- 배열 대신 컬렉션을 사용한다.

### 4. 프로그래밍 요구 사항 2를 반드시 지킨다.

- indent depth를 3이 넘지 않도록 구현한다.
- 3항 연산자를 쓰지 않는다.
- 함수가 한 가지 일만 하도록 최대한 작게 만들어라.
- 정리한 기능 목록이 정상적으로 작동하는지 테스트 코드로 확인한다.