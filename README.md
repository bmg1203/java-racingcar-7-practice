# java-racingcar-precourse

## 📋 기능 목록 
### 🛠️ 1. 자동차 이름 입력 및 검증
   - 이름을 쉼표로 구분하여 입력받음
   - 각 이름의 길이가 5자 이하인지 확인
   - 잘못된 입력 시 예외 발생
     
#### 🔍 자동차 이름 입력 및 검증 기능 테스트
- 유효한 이름이 입력되었을 때 정상적으로 리스트 반환 여부 확인
- 이름이 5자를 초과할 경우 IllegalArgumentException 발생 여부 테스트
  
### 🛠️ 2. 시도 횟수 입력 및 검증
   - 시도 횟수를 입력받고 숫자인지 확인
   - 잘못된 입력 시 예외 발생
  
#### 🔍 시도 횟수 입력 및 검증 기능 테스트
- 유효한 숫자 입력 시 정상적으로 값 반환 여부 테스트
- 숫자가 아닌 입력에 대해 IllegalArgumentException 발생 여부 테스트
  
### 🛠️ 3. 자동차 객체 생성
   - 유효한 이름으로 자동차 객체 생성
   - 초기 위치가 0으로 설정되었는지 확인
  
#### 🔍 자동차 객체 생성 및 초기 위치 테스트
- 자동차 객체 생성 후 이름과 초기 위치가 올바르게 설정되는지 확인
  
### 🛠️ 4. 랜덤 숫자로 전진 여부 결정
   - 0에서 9 사이의 랜덤 숫자를 생성
   - 랜덤 숫자가 4 이상일 경우에만 전진
     
#### 🔍 랜덤 숫자에 따른 자동차 전진 여부 테스트
- 랜덤 숫자가 4 이상일 경우 전진하고, 3 이하일 경우 전진하지 않는지 검증
  
### 🛠️ 5. 자동차 이동
   - 시도마다 각 자동차의 전진 여부를 결정하여 이동
   - 자동차의 위치가 올바르게 업데이트되는지 확인

#### 🔍 각 라운드에서 자동차 이동 여부와 위치 업데이트 테스트
- 각 라운드에서 자동차가 이동하는지 확인하는 테스트 추가
- 랜덤 숫자가 4 이상일 때 위치가 업데이트되는지 검증
  
### 🛠️ 6. 현재 상태 출력
   - 각 시도 후, 자동차의 이름과 위치를 "-" 문자로 표시하여 출력
   - 출력 형식이 요구사항에 맞는지 확인

#### 🔍 경주 시도 횟수와 출력 형식을 검증하는 테스트
- "실행 결과"가 출력되고, 각 자동차의 이름과 위치가 형식에 맞게 출력되는지 확인
- 시도 횟수만큼 출력된 결과를 검증

### 🛠️ 7. 우승자 결정 및 출력
   - 가장 많이 이동한 자동차를 우승자로 결정하고 출력
   - 여러 우승자가 있을 경우, 쉼표로 구분하여 표시
     
#### 🔍 우승자 결정 및 출력 기능 테스트
- 5회 시도 후 가장 많이 이동한 자동차를 우승자로 출력하는 기능 검증
- "최종 우승자" 출력 형식과 우승자 이름이 포함되었는지 확인

## ✅ 단위 테스트 방식 도입
- 테스트 순서: 각 기능 구현이 완료되면 해당 기능에 대해 단위 테스트를 작성하고, 이후 기능 구현과 테스트를 번갈아가며 커밋하여 코드 이력을 남김
- 테스트 커버리지: 모든 주요 기능과 예외 상황을 테스트하여 코드가 요구사항에 맞게 동작하는지 확인
- 테스트 도구: JUnit 5와 AssertJ를 조합하여 단위 테스트를 진행했으며, 다양한 조건을 체계적으로 검증

## 🔧 테스트 코드 가독성 및 신뢰성 개선
- AssertJ의 assertThat을 사용하여 가독성을 높이고 테스트 의도를 명확히 표현
- 예외 테스트에 as() 설명과 예외 메시지 검증 추가로 신뢰성 강화
- forEach 사용으로 반복 검증 코드 간결화

## 🏛️ MVC 패턴
MVC 패턴은 Model-View-Controller의 약자로, 애플리케이션을 세 가지 역할로 나누어 구조화하는 디자인 패턴. MVC 패턴은 각 역할이 분리되어 있어 코드의 유지보수성과 확장성을 높이며, 특히 대규모 애플리케이션에서 기능별 책임을 명확하게 구분하는 데 유리. 
- Model: 애플리케이션의 핵심 데이터와 비즈니스 로직을 담당.
- View: 사용자와 상호작용하는 UI를 담당. Model의 데이터를 사용자에게 시각적으로 표현하며, 사용자가 입력한 데이터를 Controller로 전달.
- Controller: 사용자 입력을 받고, 애플리케이션의 흐름을 제어. View로부터 입력을 받아 Model에 작업을 요청하고, 결과를 View에 전달하여 사용자에게 표시.

### 📐 MVC 패턴 적용 이유
역할 분리를 통해 명확한 책임을 부여하여, 코드의 가독성과 유지보수성을 높이고, 기능 간 결합도를 낮춰 확장성과 테스트 용이성을 높이기 위해 적용

### 🎨 코드에서의 MVC 패턴
Model (Car, RaceResult)
- Car 클래스는 자동차 객체의 상태와 이동 로직을 관리. 이름과 위치 데이터를 가지고 있으며, 내부의 전진 여부 로직을 통해 자신의 상태를 업데이트
- RaceResult 클래스는 경주 결과를 계산. 모든 자동차의 위치를 기반으로 최종 우승자를 결정

View (InputView, OutputView)
- InputView 클래스는 사용자의 입력을 처리하며, 자동차 이름과 시도 횟수를 입력받아 유효성을 검증
- OutputView 클래스는 경주 상태와 결과를 출력. 각 라운드의 진행 상태를 출력하고, 최종 우승자를 화면에 표시하여 사용자에게 시각적 정보를 제공

Controller (RaceController)
- RaceController 클래스는 애플리케이션의 전체 경주 흐름을 관리. 사용자의 입력을 받아 자동차 객체들을 초기화하고, 각 라운드별로 경주를 진행한 후 최종 우승자를 출력
- RaceController는 Car와 RaceResult를 활용하여 자동차의 전진 여부와 최종 결과 계산을 위임하고, View와 Model 간의 상호작용을 관리하여 프로그램의 전체 흐름을 제어

