# java-racingcar-precourse

## 기능 요구 사항
- 각 자동차에 **이름을 부여**할 수 있다. 전진하는 자동차를 출력할 때 **자동차 이름을 같이 출력**한다.
- 자동차 이름은 **쉼표**(,)를 기준으로 구분하며 이름은 **5자 이하**만 가능하다.
- 사용자는 **몇 번의 이동**을 할 것인지를 **입력**할 수 있어야 한다.
- 전진하는 조건은 0에서 9 사이에서 무작위 값을 구한 후 **무작위 값이 4 이상**일 경우이다.
- 자동차 경주 게임을 완료한 후 **누가 우승**했는지를 알려준다. **우승자는 한 명 이상**일 수 있다.
- 우승자가 여러 명일 경우 **쉼표**(,)를 이용하여 구분한다.
- 사용자가 잘못된 값을 입력할 경우 **IllegalArgumentException**을 발생시킨 후 애플리케이션은 종료되어야 한다.

## 프로그래밍 요구 사항
- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
  - 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
  - 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 **함수(또는 메서드)를 분리**하면 된다.
- **3항 연산자**를 쓰지 않는다.
- 함수(또는 메서드)가 한 가지 일만 하도록 **최대한 작게** 만들어라.
- **JUnit 5**와 **AssertJ**를 이용하여 정리한 기능 목록이 정상적으로 작동하는지 테스트 코드로 확인한다.

## 구현할 기능 목록
1. **입력 처리**
   - [x] 자동차 이름, 경주 횟수를 입력받음 (쉼표로 구분)

2. **자동차 경주 등록**
   - [x] 사용자가 입력한 자동차 이름의 유효성을 검사함  
   - [x] 자동차 이름을 Model에 넣어 List로 생성함

3. **자동차 경주 진행**
   - [x] 사용자가 입력한 경주 횟수에 따라 무작위로 번호를 추출함  
   - [x] 추출 숫자가 4 이상이면 자동차 전진시킴

4. **자동차 경주 결과**
   - [x] 가장 멀리 이동한 자동차가 우승자로 지정됨  
   - [x] 동일한 거리를 이동한 자동차는 공동 우승이 됨

5. **출력 처리**
   - [x] 각 자동차의 차수별 실행 결과를 자동차 이름과 함께 출력함  
   - [x] 최종 우승자를 출력함 (여러 명일 경우 쉼표로 구분)

6. **테스트 코드**
- **예외 처리 한 내용을 토대로 테스트 코드를 생성한다**
   - [x] 쉼표가 아닌 다른 구분자 입력한 경우  
   - [x] 빈 값이 입력된 경우  
   - [x] 자동차 이름이 다섯 글자를 초과한 경우  
   - [x] 자동차 이름이 중복되는 경우  
   - [x] 경기 횟수가 음수이거나 숫자가 아닌 경우
 

## 폴더 구조

```
src
└── main
    └── java
        └── racingcar
            ├── controller
            ├── exception
            ├── model
            ├── validation
            ├── view
            └── Application.class

└── test
    └── java
        └── racingcar

 ```

## 중요하게 생각한 부분
- 프로젝트를 최적화하자!
  > `Application.class`에서 전부 구현했던 1차 문제와 달리 기능별로 MVC 패턴을 이용해 나눴습니다. <br>
  > 요구 사항에 맞게 메서드를 최대한 나눠서 **indent(인덴트, 들여쓰기) depth**를 **3 이하**로 구현하였습니다.
  
- 하드코딩된 값을 리팩토링을 통해 상수로 바꿔 가독성을 향상시키자!
  
- 자바 컬렉션 프레임워크와 친해져 상황에 맞는 컬렉션으로 변환해 코드의 효율성을 높이자!
  > CS 스터디를 통해 배운 사용 예시를 기억하며 `List`를 `Set`으로 변환하여 중복되는 자동차 이름을 발견하였습니다.

- 에러 메시지를 `Enum`으로 관리하자!
  > 에러 메시지를 관리하기 위해 반복적으로 사용되는 문자열을 `Enum`으로 도입하여 코드의 가독성을 높였습니다. <br>
  > `Enum`의 타입 안정성을 통해 잘못된 문자열이나 오탈자 등의 오류를 피했습니다.

- 테스트 코드를 작성하여 예외 처리가 제대로 동작하는지 확인해 보자!
  > **Junit 5**, **AssertJ**를 사용해 `@Test` 어노테이션을 사용하여 코드의 신뢰성을 높였습니다.

## 고민했던 부분
### 검증은 과연 어디에서?
검증 로직을 따로 `Validation` 클래스로 분리한 뒤 이를 어디에서 수행해야 할지 고민했습니다. 최종적으로 저는 검증을 컨트롤러에서 수행하기로 결정했습니다. 이는 다음과 같은 이유 때문입니다.

1. **책임의 명확화**: 컨트롤러는 사용자 입력을 호출해 이를 처리하는 역할을 하므로, 입력값의 유효성을 검사하는 것도 자연스러운 책임으로 보았습니다. 이렇게 함으로써 각 구성 요소의 책임을 명확하게 구분할 수 있었습니다.
2. **유연한 에러 처리**: 컨트롤러에서 검증을 수행함으로써, 입력값이 유효하지 않을 경우 적절한 에러 메시지를 생성하고 사용자에게 피드백을 제공하는 것이 용이해졌습니다. 이는 사용자 경험을 향상시키는 데 중요한 요소입니다.

## 프리코스 2주차를 끝내며......
### 지원서에 작성한 목표를 얼마나 달성하고 있다고 생각하나요? 그 이유는 무엇인가요?
현재 제 목표에 비해 아직 부족하다고 느낍니다. 기존에 가지고 있던 실력보다 한 단계 높은 프리코스의 문제를 해결하는 과정에서, 다른 분들보다 더 많은 시간을 소요하고 있습니다. 하지만 결국 문제를 해결해 나가며 이렇게 제출 소감을 작성할 수 있게 되었기 때문에, 목표 달성을 위해 노력하고 있다고 생각합니다.<br>

### 지원서에 작성한 목표를 변경해야 한다고 생각하시나요? 그렇다면 그 이유와 어떤 목표로 변경하고 싶으신가요?
변경하고 싶지 않습니다. 높은 목표를 설정함으로써 그에 맞는 사람이 되기 위해 노력하고 있으며, 중간에 목표를 낮추는 것은 스스로 해이해질 것이라는 생각이 듭니다. 다만, 개인 공부 시간이 부족한 점은 인지하고 있으며, 강의를 듣는 등 학습 시간을 늘리는 목표로 발전시키고 싶습니다. <br>

### 프리코스를 진행하면서 눈에 띄는 변화나 깨달은 점이 있나요?
사실, 제 코드 리뷰를 부탁드리는 것이 부끄럽게 느껴져 아직 시도하지 않았습니다. 그러나 2주차부터는 스터디분들과 함께 코드 리뷰를 진행할 계획입니다. 그동안 다른 분들의 코드와 코드 리뷰를 통해 불필요한 코드에 대해 다시 생각해 볼 기회를 가졌습니다. 무한 if 감옥에 갇혀 있던 저에게 반복되는 구간을 메서드로 리팩토링하는 경험은 매우 소중했습니다. 이전에는 기능 구현이 80%의 성공이라고 생각했지만, 지금은 예외 처리나 코드 재사용성을 고려하는 단계에 가까워졌습니다. 이러한 변화가 스스로에게 긍정적인 자극이 되고 있습니다.
