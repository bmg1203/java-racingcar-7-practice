# java-racingcar-precourse

# 🏎️ 자동차 경주
초간단 자동차 경주 게임을 구현한다.

주어진 횟수 동안 n대의 자동차는 전진 또는 멈출 수 있다.
각 자동차에 이름을 부여할 수 있다. 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다.
자동차 이름은 쉼표(,)를 기준으로 구분하며 이름은 5자 이하만 가능하다.
사용자는 몇 번의 이동을 할 것인지를 입력할 수 있어야 한다.
전진하는 조건은 0에서 9 사이에서 무작위 값을 구한 후 무작위 값이 4 이상일 경우이다.
자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한 명 이상일 수 있다.
우승자가 여러 명일 경우 쉼표(,)를 이용하여 구분한다.
사용자가 잘못된 값을 입력할 경우 IllegalArgumentException을 발생시킨 후 애플리케이션은 종료되어야 한다.

# 💡 구현할 기능 목록

## 입력 (Input View)
- [x] 경주에 참가할 자동차 이름 입력
- [x] 시도할 횟수 입력

## 입력 검증 (Validation)
- [x] 자동차 이름
- 이름이 5글자를 초과했을 경우
- 아무것도 입력하지 않았을 경우(null)
- 쉼표 뒤에 이름이 없을 경우
- 쉼표로 시작할 경우
- 쉼표가 연달아 나올 경우
  <br><br/>
- [x] 시도할 횟수
- 숫자가 아닐 경우
- null이거나 0을 입력했을 경우

## 자동차 (Model)
- [x]  자동차

## 자동차 경주 기능 (Service)
- [x] 쉼표로 구분해서 Car 생성자 만들고 List<Car>에 넣는 기능
- [x] 무작위 숫자를 통해 전진하거나 멈추는 기능
- 0~9 사이의 숫자만 도출
- 4 이상일 때 "-" 추가
- [x] 시도할 횟수만큼 무작위 숫자를 통해 전진하거나 멈추는 기능을 반복하는 기능
- [x] 우승자 색출 기능

## 자동차 경주 컨트롤러 (Controller)
- [x] 경주 시작
- 경주에 필요한 입력 실행
  <br><br/>
- [x] 경주 종료
- 경주 결과와 우승자 출력 실행
   
## 출력 (Output View)
- [x] 경주 결과 출력
- '이름 : 전진 횟수' 형식으로 출력
  <br><br/>
- [x] 경주 우승자 출력
- 단독 우승자
- 중복 우승자: 쉼표로 구분해서 출력

  # 🌱 성장 노트 
  ## 개발적 성찰
  1. MVC 패턴을 선택한 이유
<br></br>
 **MVC패턴** Model-View-Controller 세 가지 각각의 역할을 목적에 맞게 나누어 독립적으로 처리하는 아키텍처 패턴
<br><br/>
  Model - 데이터, 비즈니스 로직을 담당하며 데이터의 CRUD 작업이 주로 수행되는 부분
<br><br/>
  View - 사용자에게 보여지는 화면 UI, Model에서 가져온 데이터를 기반으로 사용자와 소통을 하지만 데이터의 처리를 직접 수행하지 않음
<br><br/>
  Controller - 사용자의 상호작용을 통해 Model과 View를 연결하며 애플리케이션 내 중재자
<br><br/>
  여러 패턴이 존재하지만 이번 주 미션에서의 '주어진 횟수만큼 반복하여 경주 게임을 행하는 것'이 **역할을 각각 분리**해 **유지 보수성**을 높여 필요 시 해당 부분을 빠르게 수정하고, **다시 사용하기도 편리하게** 구현해야 할 것 같아서 **MVC 패턴**에 맞춰 구현했습니다.
<br><br/>
<br><br/>

  2. Exception인가, Validation인가
  <br><br/>
  사실 저는 본질이 너무 무겁게 느껴지면 사소한 것에 집착하는 고질병을 앓고 있습니다 주어진 미션을 스스로 채택한 MVC 패턴에 맞게 구현해 내는 것보다 사용자가 값을 잘못 입력했을 경우 IllegalArgumentException을 발생시킨 뒤 종료시켜야 한다는 문장을 보고서 Exception이 뻔히 적혀 있음에도 Exception은 프로그램이 실행되는 과정 중에 발생하는 것을 막기 때문에 순서의 차이가 있을 거라고 생각해서 고민해 보았는데요
<br><br/>
**Validation**은 사전에 오류를 방지, **Exception**은 진행 도중에 오류를 방지하는 것이라고 알고 있습니다! 비유해 보자면 이번 기수분들 10명과 프리코스를 완주하고 기념으로 티엔미미라는 식당에 겨우 예약했을 때 제가 필수 기재 내용을 누락시키거나 오류가 나지 않게 작성했는지 확인하는 게 Validation이고, 프리코스는 완주했지만 같이 자축할 기수분들 없이 저 혼자 방문하거나 저까지 방문하지 못하여 취소하는 예외적인 상황을 유연하게 방지할 수 있게 하는 것이 Exception인 것입니다
<br><br/>
따라서 입력받은 값이 프로그램에서 진행되기 전에 저는 패키지명을 exception이 아닌 validation으로 지정하면서 머릿속에 든 물음표 하나를 지울 수 있게 되었습니다 
<br><br/>
하지만...... 저의 validation 패키지 안에는 Exception 클래스가 존재하지요 지금 와서 회고해 보니까 그냥 분리하는 게 역할에 맞게 나누는 것 같은데 당시에는 validation이라는 검증 진행 과정에서 발생한 예외니까 Exception을 패키지 안에 넣은 것 같습니다 
<br><br/>
다음 미션 때는 **패턴에 맞게 계층을 분리해 놓은 뒤 패키지 내의 클래스가 역할에 맞게 잘 분류돼 있는지 확인하기**로 약속!
<br><br/>
  3. 검증은 View? Controller?
     다음으로 저를 한눈팔게 만들었던 것은 검증의 위치였습니다 처음에는 입력했을 때의 데이터를 검증하는 것이니까 당연히 view에서 실행해야 되지 않을까? 라는 생각이 먼저 들었는데요 그에 대한 이유는 이러했습니다
     <br><br/>
     (1) 사용자에게 데이터를 입력받는 화면이니까 입력과 동시에 검증해서 넘기면 좋잖아?
     (2) 그렇게 되면 프로그램 실행 전에 즉각적인 피드백을 제공할 수 있으니까 시작도 전에 잡아 버리자
     <br><br/>
     하지만 View 는 사용자가 어떤 데이터를 어떻게 볼지 시각적으로 표현하기, 사용자의 데이터를 처리하기 등 시각적인 요소가 중요한 컴포넌트이기 때문에 View 가 아닌 Controller 가 적합했던 겁니다...... 저는 이런 미션에서 만들라고 하는 프로그램 방식보다 웹 프로젝트로 먼저 MVC 패턴을 마주했기 때문에 Controller 의 역할을 단순히 API 를 통해 데이터를 전달하는 걸로만 한정지었는데 이 녀석 정말 중요한 녀석이었더라구요! Model과 View 를 서로 이어 주며 중재하는 역할이라는 것을 다시금 깨닫게 되었습니다 그래서 View 를 통해 받은 입력값을 Model 에서 사용하기 전에 검증을 마칠 수 있도록 Controller 에서 진행될 수 있게 수정하였습니다
     <br></br>
     <br></br>
  4. 내 인내심까지 Test 했던 JUnit
    <br></br>
     이번 주도 용기 내서 코드 리뷰 하지 못하게 만든 장본인 중 하나입니다 요구 사항에 포함돼 있던 여러 테스트 케이스를 만들어 보라는 걸 입력값에 관해서만 만들고 급하게 마무리했기 때문인데요
    <br></br>
     몇 개월 공부하면서도 아직 람다와 스트림만 보면 머리가 어지럽고 다리가 달달 떨리곤 합니다 마음먹고 공부해 보려니까 람다의 기본적인 문법 기반으로 간결하지 않냐고 줄여 놓은 코드를 아무리 봐도 아직은 헷갈리더라고요 그래서 테스트 케이스를 만들 때 사용되는 클래스들을 구경해 보았는데 Assertions 에는 특히나 람다식이 많았던 것 같아서 제가 구현한 메소드들에 대한 테스트는 만드는 데 실패하였습니다...... 

     다음 미션 때는 **JUnit 등을 활용하여 메소드를 구현할 때마다 틈틈이 테스트 케이스를 다양하게 만들어 실행해 보기**로 약속!
  5. private static void, private void? 
    <br></br>
     저는 이번 미션에서 코드의 간결성을 위해 public 메소드에서 사용될 수 있는 메소드들을 private 로 분리시켜 놓았는데 사실 static 에 대해 잘 몰랐습니다 여러 특징이 있지만 저는 인스턴스를 생성하지 않고도 접근 가능하다는 특징을 활용하기 위해 일부 메소드의 클래스 레벨을 static 으로 설정해 놓았습니다
     <br></br>
     (1) 모든 인스턴스에서 공유가 가능하므로 클래스의 인스턴스를 여러 개 만들어도 모든 인스턴스는 static 메소드의 동일한 값을 참조한다
     <br></br>
     (2) 인스턴스를 생성하지 않고도 접근 가능하다
     <br></br>

    
  ## 다음 미션 때 목표
  - [ ] 패턴에 맞게 계층을 분리해 놓은 뒤 패키지 내의 클래스가 역할에 맞게 잘 분류돼 있는지 확인하기
  <br></br>
  - [ ] JUnit 등을 활용하여 메소드를 구현할 때마다 틈틈이 테스트 케이스를 다양하게 만들어 실행해 보기
