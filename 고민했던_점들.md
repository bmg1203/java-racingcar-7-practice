# 고민했던 점들

## 1. MVC 에서의 Controller 의 역할

- MVC 에서 `Controller` 는 사용자의 요청을 받아 이를 처리하고, `View` 를 통해 사용자에게 결과를 보여주는 역할을 합니다.
- 기존에는 이 역할을 충분히 이해하지 못한 채, `Controller` 에 `run()` 메서드만 제공하는 방식으로 프로그래밍하였습니다.
- 하지만 `run()` 메서드가 모든 비즈니스 로직을 담당하는 것을 보고, 해당 메서드가 너무 많은 책임을 지고 있다고 판단하였습니다.
- `Controller` 는 사용자와 상호작용하는 역할을 가지고 있는데, `run()` 메서드 하나로 이를 전부 처리하는 것은 적절하지 않다고 판단했습니다.
- 따라서, `Controller` 는 추상화된 비즈니스 로직 수행 메서드를 외부에 노출하고, `Application` 에서 `Controller` 의 추상화된 메서드를 호출하도록 설계하였습니다.
- 이를 통해 `Controller` 가 사용자와의 상호작용을 더욱 명확하게 담당할 수 있게 되었습니다.

## 2. 자동차의 재사용을 막기 - 깊은 복사

- `RacingCar` 객체들을 관리하는 일급 컬렉션인 `RacingCars` 를 만들었습니다.
- 지금은 `RacingCars` 를 재사용할 일이 없지만, 미래에는 재사용할 가능성을 염두에 두었습니다.
- 문제는 특정 라운드를 진행할 때 사용한 `RacingCars` 를 그대로 재사용한다면, **내부의 `RacingCar` 들의 상태가 변경될 경우 그 변화가 이후 라운드에 영향을 미칠 수 있다는 점**입니다.
- 예를 들어, 리스트의 방어적 복사를 하더라도 `RacingCar` 객체 자체는 그대로 참조되기 때문에, 복사본의 `RacingCar` 상태가 바뀌면 원본에도 영향을 주게 됩니다.
- 이를 막기 위해 `RacingCars` 의 생성자에 깊은 복사를 적용해 새로운 `RacingCars` 가 생성될 때, 모든 `RacingCar` 의 참조를 복사해 새로운 객체들을 만들도록 디자인했습니다.
- 이 방법의 장점과 단점은 다음과 같습니다.

### 장단점

- **장점**
    - 복사본의 변경이 원본에 영향을 미치지 않으므로, **독립적인 상태를 유지**할 수 있습니다.
- **단점**
    - 객체를 전부 복사하게 되므로, 객체의 수가 많아질수록 **메모리 비용과 연산 비용이 발생**합니다.
    - 복사 후, 한 번만 사용하고 더 이상 사용하지 않는 일이 많아지면, 불필요한 객체가 쌓여 **GC가 자주 발생**하게 되어 **성능 저하**로 이어질 수 있습니다.

- 저는 메모리와 연산 비용을 소모하더라도 `RacingCar` 객체의 독립적인 상태를 유지하는 것이 올바르다고 생각했습니다.
- `RacingCars` 를 재사용하게 된다면, 복사된 객체는 한번 쓰고 버리는 상황보다는 계속해서 사용할 가능성이 높다고 판단했기 때문입니다.

## 3. 테스트 시 의존성을 어떻게 주입해야 할까? - Mock

- `RacingCar` 를 예시로 들겠습니다.
- `RacingCar` 는 `RacingCarValidator` 인터페이스에 의존하고 있고, 의존성 주입을 통해 `RacingCarValidator` 를 사용합니다.
- `RacingCar` 가 구체적인 타입을 알 필요가 없어 의존 역전 원칙을 지키는 방법이라고 생각합니다.
- 하지만, `RacingCar` 테스트 시 `RacingCar` 에 어떤 클래스를 주입할 것인지 생각해야 했습니다.
- 만약 특정 구현체를 선택해서 주입하게 되면, `RacingCar` 의 테스트는 해당 구현체와 의존 관계가 생깁니다.
- 테스트는 독립적으로 이루어져야 하므로, 테스트가 특정 클래스와 의존 관계가 있는 것은 옳지 않다고 판단했습니다.
- 이를 해결하기 위해서, `RacingCar` 의 테스트에서만 사용할 `RacingCarValidator` 의 테스트용 Mock 구현체를 만들었습니다. 이를 `MockRacingCarValidator` 라
  칭하겠습니다.
- `MockRacingCarValidator` 은 실제로 검증을 하는 역할이 아닌, 테스트를 위한 구현체입니다.
- `MockRacingCarValidator` 은 특정 함수의 로직을 외부에서 직접 다룰 수 있도록 디자인되었습니다.

1. `validateName()` 의 통과 여부 설정 가능.
2. `validateName()`, `validate()` 와 같은 특정 함수의 호출 여부 확인 가능.

- 이를 통해 `RacingCar` 를 테스트할 때, 내부 인터페이스의 동작 여부까지 테스트할 수 있었고, 특정 구현체에 의존하지 않도록 테스트할 수 있었습니다.

## 4. 일급 컬렉션의 역할과 일급 컬렉션의 테스트

- 일급 컬렉션은 `Collection` 을 래핑하여 외부에 여러 API(함수) 를 제공하는 역할을 한다고 생각합니다.
- 그러므로, 일급 컬렉션에 `getter` 나 `setter` 가 있다면, 일급 컬렉션의 역할에 위배되는 것이라 판단했습니다.
- 어떠한 방식으로던 내부 컬렉션을 직접 다루게 되면 `Collection` 을 포장하는 의미가 없어진다고 생각했기 때문입니다.
- 그러나, 일급 컬렉션을 테스트하는 과정에서 내부 컬렉션들의 값들이 실제로 변경되었는지 확인하기 어렵다는 문제를 발견했습니다.
- 이를 해결하기 위해 저는 세 가지 방법을 생각해 보았습니다.

### 해결하기 위한 방법

1. Adaptor 디자인 패턴을 통한 `RacingCars` 의 기능적 확장
    - 테스트 용도의 `RacingCarsAdaptor` 를 만들어 `getter` 와 `setter` 를 선언하는 방법입니다.
    - `RacingCars` 를 상속받는 `Adaptor` 를 만들어 내부 변수로 `List<RacingCar>` 를 가지도록 해 `RacingCars` 의 `Collections` 의 값을 확인할 수
      있습니다.
    - 장점: `RacingCars` 를 수정할 필요가 없습니다.
    - 단점: 코드가 많아지므로, 프로그램의 규모가 커질수록 복잡도가 올라갑니다.
2. `Java Reflection` 을 사용해 내부 `Collection` 의 값을 가져오기
    - 장점 : `RacingCars` 를 수정할 필요가 없습니다.
    - 단점 1 : 캡슐화 원칙을 위반하는 것이므로, `RacingCars` 의 코드가 변경되면 `Reflection` 코드 또한 변경해야 합니다.
    - 단점 2 : `Reflection` 을 사용하는 코드에서 문제 발생 시 원인 파악이 어려울 수 있고, 잘못된 타입 캐스팅 등의 문제가 발생할 수 있습니다.
3. `RacingCars` 에 `getter` 와 `setter` 를 만들기.
    - 장점 : 매우 간단합니다.
    - 단점 1 : 일급 컬렉션의 역할에 위배됩니다.
    - 단점 2 : 잘못된 사용의 가능성이 있습니다.
    - 단점 3 : 협업 시 함수의 의도를 파악하기 힘들 수 있습니다.

- Adaptor 를 통한 `RacingCars` 의 확장을 선택하려고 했으나, 현재 `RacingCars` 의 생성자는 깊은 복사를 수행하고 있습니다.
- 따라서, `RacingCars` 내부 `Collection` 의 객체들의 참조와 생성에 사용된 `Collection` 의 객체들은 다른 참조를 가지고 있습니다.
- 참조가 다르므로, 비교를 할 수 없어 Adaptor 는 사용할 수 없었습니다.
- RacingCars 에 `getter` 와 `setter` 를 만드는 방식은, 일급 컬렉션의 역할을 위배하는 것이라 생각해 선택하지 않았습니다.
- 결과적으로 저는 `Java Reflection` 을 사용해 내부 `Collection` 의 값을 가져오기 방식을 선택했습니다.