## 고민사항

**고민**
* Car 객체가 랜덤 숫자 생성에 관여하는 것이 옳을까?

**분석**
* Car 객체는 차 이름과 움직임에 해당하는 필드에 대한 책임만 가지는 것이 옳다고 생각함.
* 단일 책임 원칙을 찾아보며 Car 객체가 움직임에 관한 책임만 가져야 한다는 것을 깨달음.
* 또한 내부적으로 랜덤 값을 반환할 경우, 테스트가 용이하지 않다는 것을 깨달음.

**해결**
* 랜덤 숫자 발생 객체와 Car 객체를 분리

---

## 고민사항

**고민**
* String 값으로 CarNames 를 입력 받았을 때, 분리해주는 객체(CarNameParser)를 따로 만들 생각임. -> CarNameParser가 List<Name> 을 필드로 가지는 것이 맞을까?

**분석**
* 1주 차 계산기 피드백을 보며, 계산기는 말 그대로 계산에 관련된 행위만 가져야 된다는 것을 깨달았음.
* CarNameParser 도 이름을 분리해주는 것에 책임이 있지, 그 이름 값을 필드로 갖고 관리하는 것에는 책임이 없다고 생각함.

**해결**
* static 메서드를 통해 이름 분리만 하는 책임을 가지게 구현
---


## 고민사항

**고민**
* 자동차 이름을 입력받으면, 해당 자동차 이름으로 Car 객체를 생성해야함. -> 여러 값이 한 번에 들어오기 때문에, Cars 객체를 만들어서 List<Car>를 필드로 두고 상태를 관리하고 싶음. -> 이럴 경우 자동차'들'을 만드는 로직을 컨트롤러에서 구현하는게 옳을까 아니면 Cars 에서 구현하는게 옳을까?

**분석**
* Controller의 책임은 입출력 로직과 비지니스 로직을 제어하는 것. -> 자동차 생성 같은 구체적이고 세부적인 로직에는 책임이 없다고 봐야함.
* Cars의 책임은 자동차들의 상태를 관리하는 것임. -> Cars 에 자동차들을 생성하는 로직을 구현하는 것이 옳다고 생각함. -> 그렇다면 어떻게 구현해야 할까?? -> 팩토리 메서드를 사용

**해결**
* Cars 객체가 자동차 생성하는 로직에 책임을 가지고 있음. 따라서 Cars 객체에 자동차 생성 로직 구현.

---

## 고민사항

**고민**
* 랜덤 숫자를 생성하는 객체를 만들고자 함. -> 그냥 객체를 생성해서 랜덤 값을 반환하는 메서드를 구현할 경우, 랜덤 값이 계속 달라지기 때문에 테스트가 불가하다는 생각이 들었음.

**분석**
* 올바른 테스트 진행을 위해 랜덤 숫자 메서드를 인터페이스로 구현하고자 함. -> 왜냐하면 실제 콘솔에서는 랜덤 값을 반환하고, 테스트 환경에서는 다른 구현체를 만들어서 고정된 값만 반환하도록 할 것임.

**해결**
* 인터페이스를 통한 분리 진행

---

## 수정사항

**문제점**
1. 자동차 움직이는 메서드를 구현하여야 하는데 position 을 ``private final int position;`` final 처리 하였음.
2. ``private final int INITIAL_POSITION = 0;`` 상수 처리에 static 을 누락하였음.

**분석**
1. final을 제거해야 랜덤 값에 따라 position을 이동시킬 수 있음.
2. 상수에 static 을 사용 하는 이유는 메모리 할당 측면에서임 -> static 을 사용하게 되면, 클래스가 메모리에 로드될 때 한 번만 생성되며, 이후 모든 인스턴스가 이 상수를 참조함. 또한, 상수를 클래스 차원에서 공유하여 모든 인스턴스가 동일한 상수를 참조할 수 있음.

**해결**
1. ``private int position;`` 로 변경
2. ``private static final int INITIAL_POSITION = 0;``로 변경

---

## 고민사항

**고민**
* Cars 객체가 경주에 대한 책임을 가지는게 맞을까? Cars는 Car들의 상태와 변화를 관리하는 책임이 있기에 경주 로직도 안에 넣는게 맞지 않을까?

**분석**
* 만일 Cars에서 한 번에 racing 진행 -> 출력문을 Cars 객체 안에 집어넣어야 함. -> 의존성 발생
* 이 정도의 의존성을 가지는 것은 괜찮지 않나 싶긴 한데, 완벽히 의존성을 끊어내는게 좋을 것 같음 -> MVC 모델 패턴으로 구현하는 이유이기 때문.

**해결**
* 컨트롤러에서 적절하게 조합하여, 레이싱을 하면서 결과를 출력하는 로직을 만들어야 할 것 같음.
