## 고민사항

**고민**
* Car 객체가 랜덤 숫자 생성에 관여하는 것이 옳을까?

**분석**
* Car 객체는 차 이름과 움직임에 해당하는 필드에 대한 책임만 가지는 것이 옳다고 생각함.
* 단일 책임 원칙을 찾아보며 Car 객체가 움직임에 관한 책임만 가져야 한다는 것을 깨달음.
* 또한 내부적으로 랜덤 값을 반환할 경우, 테스트가 용이하지 않다는 것을 깨달음.

**해결**
* 랜덤 숫자 발생 객체와 Car 객체를 분리

---

## 고민사항

**고민**
* String 값으로 CarNames 를 입력 받았을 때, 분리해주는 객체(CarNameParser)를 따로 만들 생각임. -> **CarNameParser가 List<<CarName>> 을 필드로 가지는 것이 맞을까?**

**분석**
* 1주 차 계산기 피드백을 보며, 계산기는 말 그대로 계산에 관련된 행위만 가져야 된다는 것을 깨달았음.
* CarNameParser 도 이름을 분리해주는 것에 책임이 있지, 그 이름 값을 필드로 갖고 관리하는 것에는 책임이 없다고 생각함.

**해결**
* static 메서드를 통해 이름 분리만 하는 책임을 가지게 구현
---


## 고민사항

**고민**
* 자동차 이름을 입력받으면, 해당 자동차 이름으로 Car 객체를 생성해야함. -> 여러 값이 한 번에 들어오기 때문에, Cars 객체를 만들어서 List<Car>를 필드로 두고 상태를 관리하고 싶음. -> 이럴 경우 **자동차'들'을 만드는 로직을 컨트롤러에서 구현하는게 옳을까 아니면 Cars 에서 구현하는게 옳을까?**

**분석**
* Controller의 책임은 입출력 로직과 비지니스 로직을 제어하는 것. -> 자동차 생성 같은 구체적이고 세부적인 로직에는 책임이 없다고 봐야함.
* Cars의 책임은 자동차들의 상태를 관리하는 것임. -> Cars 에 자동차들을 생성하는 로직을 구현하는 것이 옳다고 생각함. -> 그렇다면 어떻게 구현해야 할까?? -> 팩토리 메서드를 사용

**해결**
* Cars 객체가 자동차 생성하는 로직에 책임을 가지고 있음. 따라서 Cars 객체에 자동차 생성 로직 구현.

---

## 고민사항

**고민**
* 랜덤 숫자를 생성하는 객체를 만들고자 함. -> 그냥 **객체를 생성해서 랜덤 값을 반환하는 메서드를 구현할 경우, 랜덤 값이 계속 달라지기 때문에 테스트가 불가하다는 생각이 들었음.**

**분석**
* 올바른 테스트 진행을 위해 랜덤 숫자 메서드를 인터페이스로 구현하고자 함. -> 왜냐하면 실제 콘솔에서는 랜덤 값을 반환하고, 테스트 환경에서는 다른 구현체를 만들어서 고정된 값만 반환하도록 할 것임.

**해결**
* 인터페이스를 통한 분리 진행

---

## 수정사항

**문제점**
1. 자동차 움직이는 메서드를 구현하여야 하는데 position 을 ``private final int position;`` final 처리 하였음.
2. ``private final int INITIAL_POSITION = 0;`` 상수 처리에 static 을 누락하였음.

**분석**
1. final을 제거해야 랜덤 값에 따라 position을 이동시킬 수 있음.
2. 상수에 static 을 사용 하는 이유는 메모리 할당 측면에서임 -> static 을 사용하게 되면, 클래스가 메모리에 로드될 때 한 번만 생성되며, 이후 모든 인스턴스가 이 상수를 참조함. 또한, 상수를 클래스 차원에서 공유하여 모든 인스턴스가 동일한 상수를 참조할 수 있음.

**해결**
1. ``private int position;`` 로 변경
2. ``private static final int INITIAL_POSITION = 0;``로 변경

---

## 고민사항

**고민**
* Cars 객체가 경주에 대한 책임을 가지는게 맞을까? **Cars는 Car들의 상태와 변화를 관리하는 책임이 있기에 경주 로직도 Cars 객체 안에 넣는게 맞지 않을까?**

**분석**
* 만일 Cars에서 한 번에 racing 진행 -> 출력문을 Cars 객체 안에 집어넣어야 함. -> 의존성 발생
* 이 정도의 의존성을 가지는 것은 괜찮지 않나 싶긴 한데, 완벽히 의존성을 끊어내는게 좋을 것 같음 -> MVC 모델 패턴으로 구현하는 이유이기 때문.

**해결**
* 컨트롤러에서 적절하게 조합하여, 레이싱을 하면서 결과를 출력하는 로직을 만들어야 할 것 같음.

---

## 고민사항

**고민**
* Cars 객체가 경기 우승자를 뽑는 것에 대해 책임을 가질까?

**분석**
* Cars 객체가 Car 들의 상태와 행위를 관리하기 때문에, 우승자를 뽑는 로직을 작성해도 괜찮을 것 같음(Car 의 상태 즉, position 값을 관리하기 때문)
* 하지만 다른 측면에서 보면 너무 많은 책임을 Cars에 부여하는 것 같기도 함.
* 따라서 응집성 관점에서 판단하는 것이 좋을 것 같음. -> 현재 Cars 객체 안에는 makeCars() 로직밖에 없기 때문에, getRank() 로직을 구현해도 로직이 복잡해지지 않음. 따라서, 응집성 관점에서 보았을 때, 우승자 뽑는 로직을 Cars 객체 안에 구현하는 것이 좋을 것 같음.

**해결**
* Cars 객체 안에 우승자 뽑는 메서드 구현

---

## 고민사항

**고민**
* 다양한 예외처리를 위해 어떤 입력값이 들어올 수 있는지 생각해봐야 할 필요가 있음.

**분석**

* CarName
1. "pobi, woni, jun" - 일반적인 형식 [처리 완료]
2. "poni" - 단일 값 [처리 완료]
3. "11, //, 33" - 특수 문자를 포함한 이름 [처리 완료]
4. ", , ," - 빈 문자열들이 쉼표로 구분된 경우 - [CarName 에서 처리 완료]
5. " " - 단일 공백만 입력된 경우 [CarName 에서 처리 완료]
6. null 또는 "" - null 값 혹은 빈 문자열 [처리 완료]
7. "pobi \\ woni \\ jun" - 구분자가 쉼표가 아닌 경우 [7, 8번은 구분자가 .(온점과) /(슬래시)인 경우에 대해서만 예외처리 진행]
8. "pobi \\ , woni , jun" - 구분자가 혼합된 경우

* RacingChance
1. 5 - 일반적인 형식 [처리 완료]
2. 빈 문자열이나 공백 - [Integer 변환 과정에서 처리 완료]
3. a - 문자 형식 [처리 완료]
4. null 값 [처리 완료]
5. 음수가 들어오는 경우 [처리 완료]

**해결**
* CarName 과 CarParser, 그리고 RacingChance에 적절하게 로직을 분배하여 예외처리 진행

---

## 수정사항

**문제점**
* CarName 에 ", , ," 이나 " "(단일 공백) 이 들어오면 에외처리 하지 못하고 있음

**분석**
* 처음 들어오는 문자열이 빈 값이나 null 값이 아니기 때문에 예외처리에 걸리지 않음.


~~~
private static void validateEmptyCarNames(String carNames) {
        if (carNames == null || carNames.isEmpty()) {
            throw new IllegalArgumentException(EXCEPTION_EMPTY_CAR_NAME);
        }
    }
~~~
* 현재 CarNameParser 의 예외처리 코드임

* CarName에 개별 값이 전달될 때, 예외처리 해야할 필요가 있음

**해결**
~~~
private void validateCarNameEmpty(String carName) {
        if (carName.isBlank()) {
            throw new IllegalArgumentException(EXCEPTION_EMPTY_CAR_NAME);
        }
    }
~~~
* CarName 객체에 isBlank() 메서드를 사용하여 공백 값에 대한 예외처리를 진행함

---

## 수정사항

**문제점**
* "pobi \\ woni \\ jun" - 구분자가 쉼표가 아닌 경우와 "pobi \\ , woni , jun" - 구분자가 혼합된 경우를 제대로 파악하지 못하고 있음.

**분석**
* 구분자에 대해서 예외처리 하는 메서드가 아예 없음
* 사용자가 만일 구분자를 헷갈려서 쓴다면 .(온점)과 /(슬래시) 정도만 헷갈려서 쓸 것 같음.
* 자동차 이름이 *(별) 이 될 수도 있고, 물음표를 가질 수도 있고, 특수 기호를 가질 수 도 있다고 생각함
* 따라서 위에 언급한 온점과 슬래시에 대해서만 예외처리 진행.
* 정규식을 통해 예외처리 하는 것이 코드에 효율적일 것 같음.

**해결**
~~~
private static final String WRONG_DELIMITER = ".*[./].*";

private static void validateDelimiter(String carNames) {
        if (carNames.matches(WRONG_DELIMITER)) {
            throw new IllegalArgumentException(EXCEPTION_RIGHT_DELIMITER);
        }
    }
~~~
* CarNameParser 에 잘못된 구분자에 대한 예외처리 진행.

------

## 수정사항

**문제점**
* RacingChance 에 음수가 들어오는 경우 예외처리를 진행하지 않음.

**분석**
* 시도 횟수는 음수가 될 수 없음.

**해결**
~~~
private void validateMinusChance(String racingChance) {
        if(Integer.parseInt(racingChance) < CHECK_MINUS_POINT) {
            throw new IllegalArgumentException(EXCEPTION_RIGHT_CHANCE);
        }
    }
~~~
* RacingChance 에 음수일 경우 예외를 발생시키는 로직 구현

---
