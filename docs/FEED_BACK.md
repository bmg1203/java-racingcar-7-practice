# 1주차 피드백

## 목차

1. [공동 피드백](#공동-피드백)
2. [코드 리뷰](#코드-리뷰)
3. [마무리](#마무리)

## 공동 피드백

먼저 1주차 공동 피드백을 보고, 특히 스스로의 부족한 점을 느낀 4가지를 정리해 보았습니다.

### 1. Git으로 관리할 자원을 고려한다

> Java 코드만 있으면 .class 파일을 생성할 수 있다. 따라서 Git을 통해 .class 파일을 관리할
> 필요가 없다.
>

아무리 과제 형식에 따라 빌드한 환경이라지만, `.gitignore` 까지 확인하지 않았던 것은 안좋은 습관인 것 같습니다. 원본 저장소가 나와 같은 환경인 IntelliJ 기반으로 `.gitignore`가 작성되어
다행이지, Eclipse 기준이었다면 `out` 폴더를 git에 업로드하는 불상사가 일어날 뻔했습니다. 그랬다면 아주 부끄러웠을 일입니다..

.class에 대해서도 그동안 IDE에 매몰되어, 이것이 정확히 무엇인지 잊었던 것 같습니다.

백엔드로서의 기본이 부족함에 반성하게 되었습니다.

때문에, 위 언급된 문장을 보고 .class에 대해 아래와 같이 정리해보았습니다.

---

.class 파일은 Java 소스 코드(.java)를 컴파일할 때 생성됩니다.

구체적인 시점은 다음과 같습니다.

1. 컴파일 시점
    - Java 소스 코드(.java)를 javac 명령어로 컴파일할 때
    - IDE에서 프로젝트를 빌드(Build)할 때
    - IDE에서 코드를 실행(Run)할 때
    - Maven이나 Gradle 같은 빌드 도구로 프로젝트를 빌드할 때
2. .class 파일의 특징:
    - Java 바이트코드를 포함
    - JVM(Java Virtual Machine)이 실행할 수 있는 형태
    - 중간 언어(Intermediate Language) 형태
    - 플랫폼 독립적 (어떤 운영체제에서든 JVM만 있으면 실행 가능)
3. 일반적인 저장 위치:
    - IDE 사용 시:
        - Eclipse: `/bin` 또는 `/target/classes` 폴더
        - IntelliJ: `/out` 또는 `/target/classes` 폴더
    - Maven 프로젝트: `/target/classes` 폴더
    - Gradle 프로젝트: `/build/classes` 폴더
4. class 파일이 Git에서 제외되는 이유:
    - 소스 코드(.java)만 있으면 언제든 다시 생성 가능
    - 개발 환경마다 다르게 생성될 수 있음
    - 저장소 크기를 불필요하게 증가시킴
    - 바이너리 파일이라 버전 관리가 효율적이지 않음

.class 파일은 프로그램을 실행하기 위한 중간 산출물로, 소스 코드를 컴파일할 때마다 새로 생성됩니다.<br/>
1주차 과제의 `.gitignore`에서는 IntelliJ의 `/out` 패키지를 제한했기에, 따로 .class파일이 업로드 되지 않았습니다.

### 2. 커밋 메시지를 의미 있게 작성한다

> Merge pull request #123 from someuser/somebranch<br>
> 이처럼 커밋 메시지를 명령문으로 작성한다는 것은, git의 빌트-인 컨벤션(Built-in Convention)을 그대로 따른다는 것을 의미합니다.

이는 김은호 님의 '좋은 git 커밋 메시지를 작성하기 위한 7가지 약속' 게시글 중 일부입니다.

저는 커밋 제목을 명령조로 사용하는 것이 편의성, 그리고 공통 컨백션 규칙으로서 필요한 것이라 생각했습니다.
하지만 위와 같은 사실을 새로 알게되어 흥미로웠습니다. <br>
다음과 같이 커밋 명령어 앞에 If applied, this commit will를 붙힌다고 생각하니, 단순한 명령조보단 오히려 개발 자체를 표현하는 글로써 와닿습니다.<br>

```
- (If applied, this commit will) Refactor subsystem X for readability
- (If applied, this commit will) Update getting started documentation
```

또한, 1주차에 한글로 커밋 제목을 작성하는 과정에서 "수정한다"(문장) 혹은 "수정"(구문) 중 어느것을 사용해야 할까 고민했었습니다.<br>
If applied, this commit will를 적용한다고 생각했을 때, "수정"(구문)과 같이 작성하는 것이 의미적으로 가깝다고 느껴 차주부터 커밋 제목에 반영하고자 합니다.

### 3. 커밋 메시지에 이슈 또는 풀 리퀘스트 번호를 포함하지 않는다

> 일부 프로젝트에서는 작업을 이슈 또는 풀 리퀘스트와 연결하기 위해 커밋 메시지에 이슈 또는 풀 리퀘스트 번호를 포함하기도 한다. 그러나 이 접근 방식은 원본 저장소의 관련 없는 이슈 또는 풀 리퀘스트에 영향을
> 미칠 수 있다. 따라서 이 과정에서는 커밋 메시지에 이슈 또는 풀 리퀘스트
> 번호를 포함하지 않는다
>

지난 과제에서, AngularJS Git Commit Message Conventions에 따라
본문 Footer에 Closes #1 와 같이 Commit을 작성했습니다.

이는 개인 공부 차원에서, Github-flow 활용 및 Github의 Project 기능 활용을 위해 사용했습니다.

별도의 브랜치들을 Squash를 통해 병합하여 개인 develop 브랜치에는 기능 목록만 PR을 진행하되,<br>
세부적인 작업들을 개별 PR 링크를 통해 추적 가능하도록 작업했습니다.<br>
이 과정에서, 브랜치 관리에 대한 flow나 병합 방식의 차이에 대해 배울 수 있었습니다.

Closes #1 과 같이 작성했을 때, #1의 링크가 개인 저장소의 PR(#1)과 연동되었기에, 원본 저장소에 영향이 가지 않을거라 잘못 판단했습니다.<br>
위에 언급된 것과 같이 원본 저장소에 영향을 줄 수 있다면, 앞으로 사용해서는 안됩니다.<br>
혹시나 1주차에 저때문에 피해를 보신분이 없었으면 하네요..😓

아쉽게도 commit에 PR 번호 할당를 명시하는 것이 제한되었으니, 이전만큼 개발 과정을 세세히 공유하자는 목표는 어려울지도 모르겠습니다. <br>
하지만, 그만큼 의미있는 커밋을 작성하여, 커밋만으로도 작업 명세가 가능하도록 노력해야겠습니다.

### 4. 축약하지 않는다

- 객체 지향 생활 체조 원칙 5: 줄여쓰지 않는다(축약 금지)

> 누구나 실은 클래스, 메서드, 또는 변수의 이름을 줄이려는 유혹에 곧잘 빠지곤 한다. 그런 유혹을
> 뿌리쳐라. 축약은 혼란을 야기하며, 더 큰 문제를 숨기는 경향이 있다. 클래스와 메서드 이름을 한
> 두 단어로 유지하려고 노력하고 문맥을 중복하는 이름을 자제하자. 클래스 이름이 Order라면
> shipOrder라고 메서드 이름을 지을 필요가 없다. 짧게 ship이라고 하면 클라이언트에서는
> order.ship()라고 호출하며, 간결한 호출의 표현이 된다.
>

축약 금지의 기본은 지켜졌다고 생각합니다. `getCustomSeparator` 와 같이 메소드 이름 만으로 기능 인지가 가능하도록 구현했기 때문입니다.

하지만, 위 규칙에서 말하는 “간결한 호출의 표현”에 대한 것은 고려가 부족했던 것 같습니다.

```
// 기존의 코드
Parser.parseItem();
Parser.parseInput();

// 간결한 표현으로 수정한 코드
Parser.item();
Parser.input();
```

위와 같이, 코드를 좀 더 간결하게 사용할 수 있다는 것을 생각하지 못했습니다.

물론, 이 과정에서 Parser.item(); 과 같이 정확한 의미를 추론하기 어려운 작명이 생길 수 있습니다.

중요한 것은, 그렇다면 “근본적으로 item 이라는 표현이 올바른 것인가?”와 같은 고민을 하지 않았다는 것입니다.

기존의 parseItem() 메소드는 문자열이 숫자 형식인지 정규표현식으로 검증한 후,<br>
숫자가 맞다면 Integer로 변환하고 아니라면 에러를 발생시키는 메소드입니다.

메소드의 주 기능이 "문자열을 정수로 변환"하는 것이므로, toInteger()와 같이 좀 더 직관적인 이름을 고려 했어야 했습니다.

```
// 개선 이전
Parser.parseItem();
// 개선 후 
Parser.toInteger();
```

## 코드 리뷰

다음은 1주차 코드 리뷰에서 특히나 개선이 필요한 부분을 정리했습니다.

### 1. 에러 메시지 분리와 책임 소재

```
package calculator.common;

public enum ErrorMessages {
```

1주차 코드에는 다음과 같은 구조가 있었습니다

- ErrorMessages라는 enum 클래스를 common 패키지에 두어 에러 메시지를 관리
- 주로 구분자 관련 메시지들이 포함되어 있었음

이에 리뷰어분께서 다음과 같은 피드백을 주셨습니다:

> 메시지를 따로 관리하는 것 좋네요 👍
> 다만 이 메시지들을 사용하는 객체들에서 분리할 만큼 전역적인 메시지들인지 약간 고민이 되는 것 같아요. 전체적으로 구분자에 대한 메시지인데, 구분자 객체가 있었다면 스스로 책임질 수 있지 않았을까요?
>

확실히 이점은, 설계 상 책임 분리의 기준이 빈약했던 점이라 생각했습니다.

이에 작성한 코드의 문제점은 다음과 같이 정리했습니다

1. **책임 분리 기준의 부재**: 단순히 가독성만을 위한 분리였을 뿐, 명확한 설계 기준이 없었습니다.
2. **부적절한 분리**: 구분자 관련 메시지들을 전역적으로 관리할 필요가 없었습니다.
3. **객체 책임의 부재**: 구분자 객체가 자신의 에러 메시지를 직접 관리했어야 했습니다.

개발 단계에서는 단순히 코드 가독성 향상이라는 표면적인 이점만 고려했을 뿐, 객체 책임의 관점에서는 깊이 있게 고민하지 못했습니다.<br>
특히나 이번 과제에서 클래스를 명확히 구분하는 것이 어려웠는데, 목적을 확실히 분리할 필요성을 느꼈습니다.

이 문제를 개선하기 위해 다음 3가지 방안을 정리했습니다:

1. 클래스를 분리할 때는 단순한 가독성이 아닌, 명확한 목적과 책임 소재를 기준으로 해야 합니다.
2. 에러 메시지는 해당 도메인 객체가 직접 관리하도록 설계해야 합니다.
3. common 패키지에는 정말 공통적으로 사용되는 요소들만 위치시켜야 합니다.

### 2. -er 객체 사용에 대한 피드백

1주차 코드에는 다음과 같은 클래스들이 존재했습니다.

- XXXCalculator
- XXXValidator

이러한 클래스들은 대부분 정적 메서드들의 집합으로 구성되어 있었습니다.

이에 리뷰어분께 다음과 같은 피드백을 받았습니다.

> -er(-or) 객체들이 항상 나쁜 건 아닙니다. 하지만 Number(s)라는 객체가 존재해서 담당했어야 할 책임을 여러 곳으로 찢으면서 다양한 Calculator, Validator, Initializer 등의
> 클래스가 생겨났습니다. 이들은 보통 정적 메서드만 가진, 객체가 아닌 수행기에 불과합니다.
>

이를 바탕으로 제가 작성한 코드의 주요 문제점은 다음과 같이 정리했습니다.

1. **객체 없는 객체지향**: 클래스들이 단순히 관련 메서드들을 묶는 용도로만 사용되었습니다.
2. **책임의 분산**: 핵심 도메인 객체(예: Numbers)가 가져야 할 책임이 여러 Utility성 클래스들로 분산되었습니다.
3. **구조적 한계**: MVC 패턴을 목표로 설계했으나, 실제로는 단순한 코드 다발의 묶음에 그쳤습니다.

개발 단계에서 미쳐 생각하지 못한, 객체 지향에 있어 큰 실책이라 느꼈습니다.

그래서, 2주차 과제에서 꼭 개선된 모습을 보여야겠다 다짐했습니다.

이 문제를 개선하기 위해 다음 3가지 방안을 정리했습니다.

1. 핵심 도메인 객체를 먼저 식별하고, 해당 객체가 가져야 할 책임을 명확히 정의해야 합니다.
2. Utility성 클래스들의 책임을 최소화하고, 가능한 한 도메인 객체에 책임을 부여해야 합니다.
3. 정적 메서드의 사용을 최소화하고, 객체의 상태와 행위를 더 유기적으로 결합해야 합니다.

단순히 코드를 기능별로 분류하는 것이 아니라, 실제 도메인 객체를 중심으로 설계하는 것이 좀 더 객체지향적 접근 방식에 가깝다는 것을 생각해볼 좋은 기회였습니다.

### 3. Parser 클래스의 과도한 책임 집중 문제

1주차 코드에는 다음과 같은 책임들이 Parser 클래스에 집중되어 있었습니다

- 입력값 처리
- 구분자 처리
- 숫자 처리

이러한 클래스는 util 패키지에서 시작해 점차 책임이 커지면서 domain 패키지로 이동하게 되었습니다.

이에 리뷰어분께서 다음과 같은 피드백을 주셨습니다:

> Parser의 책임이 막중하네요..! 입력값, 구분자, 숫자에 대한 책임을 모두 맡고 있어요. 혹시 조금 분리할 방법은 없을까요?
>

이를 바탕으로 정리한 코드의 문제점은 다음과 같았습니다.

1. **과도한 책임 집중**: Parser라는 큰 틀을 먼저 잡아버려서, 모든 파싱 관련 책임이 한 클래스에 집중되었습니다.
2. **모호한 클래스 성격**: util 패키지에서 domain 패키지로의 이동은 클래스의 성격이 불분명했음을 보여줍니다.
3. **기준 미달**: '기능별로 잘 구분된 클래스'라는 최소한의 설계 기준조차 지키지 못했습니다.

개발 단계에서 이러한 문제를 인지하지 못한 것은, 접근법 자체의 실수였다고 생각합니다. Parser라는 이름으로 인해 모든 파싱 관련 책임이 이 클래스에 포함되어야 한다고 잘못 판단했기 때문입니다.

특히 아쉬웠던 점은, 객체지향적이지 못했다는 점을 넘어서서 제가 설정했던 기본적인 설계 기준조차 지키지 못했다는 것입니다. 이는 단순한 지식의 부족이 아닌, 설계 원칙의 실천 부족으로 인한 것이었습니다.

이 문제를 개선하기 위해 다음 방안을 정리했습니다

1. Parser의 책임을 기능별로 명확하게 분리하여 별도의 클래스로 나누어야 합니다.
2. 각 클래스의 패키지 위치를 그 성격에 맞게 명확히 정의해야 합니다.

마지막으로, 설계 단계에서 세운 기준을 잘 지키지 못한 것을 반성했습니다. 틀린 기준이면 틀린 점 하나 개선하면 되겠지만, 기준이 없는 코드는 하나 개선하면 또 하나의 문제가 발생할 지도 모릅니다. 협업 환경 뿐만
아니라 유지 보수 측면에서도 최악이죠. 이점을 명심하고 개발할 수 있도록 노력해야겠습니다.

### 4.CalculatorService

이는 이채영님의 PR(#557)의 코드리뷰들를 참고하여 스스로를 검토해 보았습니다.

```
public class CalculatorController {
	private final InputView inputView;
	private final OutputView outputView;

	public CalculatorController() {
		this.inputView = new InputView();
		this.outputView = new OutputView();
```

위 코드에 대해 다음과 같은 리뷰가 달렸습니다.

- "Controller 내부에서 View를 생성하지 말고 외부에서 주입받아 사용하세요. (테스트와 확장성을 위해)"
- "View가 단순하다면 static 메서드로 만들어도 되지만, 향후 확장성을 고려하면 신중히 결정하세요."
- "MVC 패턴의 관점에서 Controller와 View는 분리되어야 합니다."

공통적으로 MVC 패턴으로서 명확한 분리를 말하고 있습니다.

그리고 제 코드는 다음과 같습니다.

```
public class CalculatorService {
	public static final String ENTER_NUMBERS = "덧셈할 문자열을 입력해 주세요.";
	public static final String DISPLAY_RESULT = "결과 : ";

	private final IOHandler ioHandler;
	private final NumberCalculator calculator;
	private final Parser parser;
	
	public CalculatorService() {
		this.ioHandler = new ConsoleUtil();
		this.calculator = new NumberCalculator();
		this.parser = new Parser();
	}
```

앞선 피드백에 빗대어 개선이 필요한 점을 다음과 같이 정리했습니다.

1. 내부에서 의존성을 직접 생성하고 있어서 이전 코드와 동일한 문제가 있습니다.
2. 일반적인 Controller의 역할에 좀더 가깝습니다.
   Service는 일반적으로 비즈니스 로직을 담당하는 계층을 의미하는데, 현재 이 클래스는 입출력 처리 (UI 계층), flow 제어 (Controller 계층), 계산 로직 조정 (Service 계층)의 책임이
   모두 있습니다.

저는 처음에 main은 오로지 실행의 역할만 수행해야 한다고 판단했습니다. 때문에 의존성을 관리하는 것 또한, 하위 클래스에서 관리하도록 분리해야 한다고 생각했습니다.

이로 인해 해당 클래스의 책임이 너무 커지는 것을 고려하지 못했습니다. Controller의 역할로 상정했더라도, 단순 flow 처리 외에 비즈니스 로직의 책임 또한 포함하게 되었기 때문입니다.<br>
또한, 테스트 의존성 관리의 어려움과 같은 2차적인 문제들을 고려하지 않은 것도 큰 실책으로 느껴졌습니다.

위 문제를 해결하기 위해 다음과 같이 코드를 개선할 수 있습니다.

```
public static void main(String[] args) {
	IOHandler ioHandler = new InputView();
	CalculatorService calculatorService = new CalculatorService();
	Parser parser = new Parser();
	CalculatorController controller = new CalculatorController(ioHandler, calculatorService, parser);
}

public CalculatorController(IOHandler ioHandler,
	CalculatorService calculatorService,
	Parser parser) {
	this.ioHandler = ioHandler;
	this.calculatorService = calculatorService;
	this.parser = parser;
}
```

이를 통해 다음과 같은 장점을 얻을 수 있습니다.

- 테스트가 용이함 (Mock 객체 주입 가능)
- 유연성이 높음 (다른 구현체로 쉽게 교체 가능)
- 객체지향 원칙에 더 부합함

## 마무리

피드백을 종합적으로 살펴보았을 때, 현재 제 코드의 가장 큰 문제점은<br> <span style="color: lightgreen">**코드의 책임 분리**</span>가 명확히 이루어지지 않음에 있었습니다.

이 점을 명심하고 설계 단계에서 더 명확한 기준을 가질 수 있도록 고민해야겠습니다.

---
[🔝 맨 위로 돌아가기](#1주차-피드백)