# 원시값 포장

### 학습하게 된 이유

--------

![img.png](image/축약하지않는다.png)

* 1주 차 피드백을 참고하다 보니, 객체 지향 생활 체조 원칙에 대해 학습할 수 있었고, 이 원칙 중에 원시값 포장이 있었습니다. 2주 차 미션은 객체 지향 생활 체조 원칙에 따라 작성할 것이기에, 원시값 포장을 학습할 필요가 있었습니다.


### 원시값 포장이란 무엇인가?

--------
* 원시 값 포장이란, 원시 타입이나 문자열을 객체로 감싸는 작업입니다.

### 왜 원시 값 포장을 사용해야 하는가?

--------
* 의미를 명확히 할 수 있기 때문입니다. int, String 같은 원시 타입을 그대로 쓰면, 코드에서 정확한 의미를 나타내기 힘듭니다. 하지만 Age, Name 클래스를 만들어 원시값을 포장할 경우, 그 의미가 더 명확해집니다.
* 데이터 무결성을 보장할 수 있습니다. Age 클래스에 0보다 큰 값만 가진다는 검증 로직을 작성하여, 유효하지 않은 나이를 가진 객체가 생성되지 않도록 보장할 수 있습니다.
* 관련된 로직을 캡슐화 할 수 있습니다. Age 클래스에 관련된 검증로직을 Age 클래스에만 작성하여, 외부에서 해당 값이나 메서드를 조작할 필요가 없게 됩니다.


### 원시값 포장의 사용법

-------
~~~
public class Age {
    private final int value;

    public Age(int value) {
        if (value < 0) {
            throw new IllegalArgumentException("나이는 0 이상이어야 합니다.");
        }
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}
~~~

* 이러한 방식으로 원시값 포장을 사용할 수 있습니다. 


### 원시값과 VO의 차이점

-------
* 원시값 포장에 대해 학습하니, "사람들이 흔히 쓰는 VO와 원시값의 차이는 뭘까? 형식은 비슷한데....." 라는 의문점이 들었고 해당 내용에 대해 학습하게 되었습니다.

**VO**

* 도메인에서 1개, 혹은 여러 개의 속성을 묶어서 특정 값을 나타내는 객체를 말합니다. 

예시
~~~
public class Money {
    private final int amount;
    private final String currency;

    public Money(int amount, String currency) {
        if (amount < 0) throw new IllegalArgumentException("금액은 0 이상이어야 합니다.");
        this.amount = amount;
        this.currency = currency;
    }

    public int getAmount() {
        return amount;
    }

    public String getCurrency() {
        return currency;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Money money = (Money) o;
        return amount == money.amount && currency.equals(money.currency);
    }

    @Override
    public int hashCode() {
        return Objects.hash(amount, currency);
    }
}
~~~

* 위 형식 처럼 VO는 amount 와 currency 를 동시에 묶어서 객체로 표현할 수 있습니다.

* 그리고 VO가 되려면 아래에 있는 조건을 꼭 만족해야 합니다.
    1. equals & hashcode 메서드를 재정의해 동등성 비교가 가능하다.
    2. 불변 객체이다.

**차이점 정리**

| 원시 값 포장                         | VO                             |
|--------------------------------------|-----------------------------------|
| 단일 원시 값을 의미 있는 객체로 포장 | 여러 속성을 가진 불변 객체                |
| 값의 의미 명확화, 무결성 유지        | 속성 조합으로 하나의 의미 있는 개념 표현   |
| 주로 하나의 값만 포함               | 여러 개의 관련 속성 포함                 |
| 동등성 비교를 반드시 구현할 필요 없음 | 속성 값이 동일하면 같은 객체로 간주        |

---

Ref) https://itstory1592.tistory.com/116, https://engineerinsight.tistory.com/37, https://www.youtube.com/watch?v=z5fUkck_RZM
