# 고민한 내용들

- 이번 프로젝트에서는 단순히 요구사항을 구현하는 데 그치지 않고, **객체지향적인 설계와 확장성을 고려한 구조**로 구현하고자 했습니다.

---

## 1. 과제의 모든 요구사항 충족

프로젝트는 아래와 같은 **주요 요구사항을 충족**하도록 구현했습니다.

- 지정된 시도 횟수 동안 여러 대의 자동차가 전진 또는 멈출 수 있도록 게임을 진행합니다.
- 각 자동차는 이름을 가지고 있으며, 이름이 유효하지 않거나 입력이 잘못된 경우 예외 처리를 수행합니다.
- **자동차 전진 여부는 무작위로 결정**되며, 결과는 각 자동차의 이름과 함께 출력됩니다.
- 최종적으로 **가장 멀리 간 자동차를 우승자로 결정**하며, 우승자가 여러 명일 경우 공동 우승으로 표시합니다.
- 요구사항 외에도 **입력값 검증, 에러 메시지 설정, 테스트 코드 작성** 등을 통해 안정성과 신뢰성을 높였습니다.

## 2. 객체지향적인 설계

### 설계의 기본 방향

이 프로젝트는 **객체지향적인 설계와 단일 책임 원칙(SRP)을 준수하여 확장 가능한 구조**를 구현하는 것을 목표로 삼았습니다. 또한, **추가적인 요구사항이 발생하더라도 쉽게 확장**할 수 있도록 각 객체의
책임을 명확히 분리했습니다.

### 클래스와 역할 분리

- `Application`: **프로그램의 시작점**으로, `RacingGame`을 호출하여 게임을 실행합니다.
- `RacingGame`: **게임의 흐름을 제어하는 중심 클래스**로, 시도 횟수를 바탕으로 게임을 라운드별로 진행하고, 최종 우승자를 결정합니다. 새로운 게임 규칙이 추가될 경우에도 `RacingGame`을
  확장하여 수정할 수 있습니다.
- `Car`: 개별 자동차 객체로, 이름과 위치를 관리하며, **전략 패턴**을 사용하여 전진 여부를 결정합니다. `MoveStrategy` 인터페이스를 통해 **전진 조건을 유연하게 확장**할 수 있습니다.
- `MoveStrategy` 인터페이스와 `RandomMoveStrategy` 구현체:
    - `MoveStrategy`는 전진 조건을 설정하는 인터페이스로, 다양한 전진 조건을 유연하게 추가할 수 있는 구조입니다.
    - `RandomMoveStrategy`는 무작위 값에 따라 전진 여부를 결정하는 전략으로, 전진 조건이 다변화될 경우 새로운 전략 클래스를 추가해도 `Car` 클래스에는 영향이 없도록 설계되었습니다.
- `InputView`와 `OutputView`: **입력과 출력을 담당하는 클래스**로, 게임의 시작과 종료 시 입력과 결과 출력이 이루어집니다. **입력값 유효성 검사와 예외 처리**도 `InputView`에서
  수행합니다.

### 확장성을 고려한 설계

- 이 설계 방식은 새로운 이동 전략, 다양한 게임 규칙 등 **추가적인 요구사항을 반영하는 데 유리**합니다.
- 예를 들어, 전진 조건이 무작위 값 대신 속도나 날씨에 따른 조건으로 변경된다면 새로운 `MoveStrategy` 구현체를 추가하는 것만으로 해결할 수 있습니다.
- 자동차 이외의 새로운 이동 수단(예: 오토바이, 자전거)도 필요하다면 `MoveStrategy`를 사용하는 구조이므로 별도의 구현체만 추가해 `RacingGame`에서 사용할 수 있습니다.

## 3. 예외 상황 고려 및 테스트 코드 작성

### 예외 상황

- 프로젝트는 다양한 **입력값 검증과 예외 처리를 포함**하여, 잘못된 입력에 대해 안정성을 확보했습니다.
- 자동차 이름이 1~5자가 아닐 경우 예외가 발생하며, 시도 횟수가 1 미만일 때도 `IllegalArgumentException`을 발생시키도록 하여 프로그램의 신뢰성을 높였습니다.

### 테스트 코드 작성

테스트 코드는 각 클래스와 메서드별로 작성되었으며, **테스트의 명확성과 가독성을 높이기 위해 의미 있는 네이밍**을 사용했습니다.

- **테스트 네이밍**: `자동차_이동_성공_테스트`, `시도_횟수_유효성_검사`, `공동_우승자_검증` 등 메서드 이름을 통해 각 테스트가 무엇을 검증하는지 명확히 알 수 있습니다.
- **테스트의 가독성**: 무작위성이 개입되는 테스트에서는 `assertRandomNumberInRangeTest`를 사용해 무작위 값을 고정하여 예측 가능한 결과를 검증합니다.
- **주요 테스트 항목**:
    - **자동차 이동**: 무작위 값을 고정하여 전진 조건이 충족될 때와 그렇지 않을 때의 결과를 확인했습니다.
    - **유효성 검사**: 잘못된 자동차 이름과 시도 횟수가 입력되었을 때 올바르게 예외가 발생하는지 테스트했습니다.
    - **공동 우승자**: 공동 우승자가 발생할 경우 해당 결과가 정확히 출력되는지 검증했습니다.

## 4. 요구사항과 설계의 의미 및 지향점

이 프로젝트는 **기본적인 요구사항을 충족**하는 데 그치지 않고, **확장 가능하고 유연한 설계를 목표**로 하여 객체지향 원칙을 적용했습니다. 이렇게 설계된 이유와 지향하는 방향은 다음과 같습니다.

1. **유지보수성과 확장성**:
    - 요구사항이 변경되거나 새로운 기능이 추가될 때, 각 클래스의 책임이 명확히 분리되어 있어 수정할 부분을 쉽게 파악할 수 있습니다.
    - 각 기능은 독립적으로 존재하므로, 확장 시에도 기존 코드에 큰 영향을 주지 않도록 설계했습니다.
2. **재사용성**:
    - 전진 조건과 같은 주요 기능을 `MoveStrategy`로 분리하여 **다양한 전진 조건**을 손쉽게 추가할 수 있으며, 다른 클래스에서도 재사용할 수 있습니다.
3. **테스트 가능성**:
    - 무작위성이 개입되는 게임이므로 `assertRandomNumberInRangeTest`와 같은 제어 가능한 테스트 환경을 구축하여 **신뢰성 있는 테스트**를 수행할 수 있도록 했습니다.

## 5. 추가적인 고민과 예상 시나리오

현재 요구사항은 충족했지만, 추가적으로 고려할 부분과 개선 가능성을 염두에 두고 있습니다.

- **다양한 이동 전략 추가**: 현재는 무작위 이동 조건만 존재하지만, 예를 들어 날씨, 시간, 자동차의 성능에 따른 이동 전략을 추가할 수 있습니다. 이 경우, `MoveStrategy` 인터페이스를 통해
  확장성을 확보할 수 있습니다.
- **자동차 외의 이동 수단 추가**: 자동차 이외의 새로운 이동 수단(오토바이, 자전거 등)이 필요할 때, 각 이동 수단의 특성에 따라 전진 조건을 다르게 설정할 수 있는 구조로 확장 가능합니다.
- **게임 규칙의 다변화**: 시도 횟수 외에도 시간 제한, 점수 계산 등 새로운 규칙이 추가될 수 있으며, 이를 반영할 수 있도록 `RacingGame`을 확장하거나 규칙을 설정하는 클래스를 별도로 설계할 수
  있습니다.

---

## 사용된 주요 API

이 프로젝트에서는 **테스트와 검증의 신뢰성을 높이기 위해 다양한 API**를 사용했습니다. 주요 API와 그 역할은 아래와 같습니다:

### 1. `camp.nextstep.edu.missionutils.test.Assertions`

이 라이브러리의 `Assertions` 클래스는 주로 **무작위 값 제어와 예외 테스트를 지원**하여 예측 가능한 테스트 환경을 제공합니다.

- **`assertRandomNumberInRangeTest`**
    - **설명**: 무작위성이 포함된 테스트에서 특정 고정 값을 설정하여 예측 가능한 테스트를 수행하도록 합니다.
    - **사용법**: `assertRandomNumberInRangeTest(Runnable test, int... values)`
    - **예시**:

        ```java
        assertRandomNumberInRangeTest(() -> {
            run("pobi,woni", "3");
            assertThat(output()).contains("pobi : -", "woni : ");
        }, 4, 3); // 무작위 값 대신 4와 3을 사용
        ```

- **`assertSimpleTest`**
    - **설명**: 예외 발생 여부를 간단히 검증할 때 사용됩니다. 코드 블록이 정상적으로 실행되는지 확인할 수 있습니다.
    - **사용법**: `assertSimpleTest(Runnable test)`
    - **예시**:

        ```java
        assertSimpleTest(() -> {
            int result = someMethod();
            assertThat(result).isEqualTo(10);
        });
        ```

### 2. `org.assertj.core.api.Assertions`

이 라이브러리는 **AssertJ**에서 제공하는 검증 도구로, **유연하고 읽기 쉬운 방식으로 다양한 조건을 검증**할 수 있게 합니다.

- **`assertThat`**
    - **설명**: 특정 값이 예상한 조건을 만족하는지 검증합니다.
    - **사용법**: `assertThat(actual).isEqualTo(expected)`, `assertThat(actual).isGreaterThan(value)`
    - **예시**:

        ```java
        assertThat(result).isEqualTo(10); // result가 10과 일치하는지 검증
        ```


- **`assertThatThrownBy`**
    - **설명**: 특정 코드가 예외를 발생시키는지 검증하며, 발생한 예외의 타입과 메시지를 확인할 수 있습니다.
    - **사용법**: `assertThatThrownBy(() -> { /* code */ }).isInstanceOf(ExpectedException.class)`
    - **예시**:

        ```java
        assertThatThrownBy(() -> {
            someMethodThatThrowsException();
        }).isInstanceOf(IllegalArgumentException.class)
          .hasMessageContaining("Expected error message");
        ```

### 3. `camp.nextstep.edu.missionutils.test.NsTest`

`NsTest`는 **입력값과 출력값을 직접 제어할 수 있는 유틸리티**로, 입력과 출력을 설정해 테스트에서 프로그램 실행 흐름을 검증할 수 있습니다.

- **`run`**
    - **설명**: 프로그램에 특정 입력값을 제공하여 실행하는 메서드입니다.
    - **사용법**: `run(String... args)`
    - **예시**:

        ```java
        run("pobi,woni", "3"); // 프로그램이 pobi,woni와 3이라는 입력값으로 실행됨
        ```

- **`output`**
    - **설명**: 프로그램의 실행 결과를 텍스트로 가져와 검증할 수 있습니다.
    - **사용법**: `output()`
    - **예시**:

        ```java
        assertThat(output()).contains("pobi : -", "woni : ");
        ```

이와 같은 API를 통해 **무작위 요소와 예외 상황을 제어**하며, 일관성 있는 테스트 환경을 제공하여 프로젝트의 신뢰성을 높일 수 있었습니다.

---

## 피드백 반영 체크리스트

- [x]  **요구 사항을 정확하게 준수한다**

과제 진행 요구 사항, 기능 요구 사항, 프로그래밍 요구 사항을 모두 충족했는지 확인했습니다.

- [x]  **기본적인 Git 명령어를 숙지한다**

Git의 `add`, `commit`, `push` 등의 명령어를 사용해 버전 관리를 했습니다.

- [x]  **Git으로 관리할 자원을 고려한다**

`.class` 파일과 `.idea` 등 자동 생성 파일은 `.gitignore`에 추가하여 관리 대상에서 제외했습니다.

- [x]  **커밋 메시지를 의미 있게 작성한다**

작업 내용을 명확히 알 수 있도록 커밋 메시지를 작성했습니다.

- [x]  **커밋 메시지에 이슈 또는 풀 리퀘스트 번호를 포함하지 않는다**

커밋 메시지에 이슈 번호를 포함하지 않았습니다.

- [x]  **풀 리퀘스트를 만든 후에는 닫지 말고 추가 커밋을 한다**

PR을 생성한 후 추가 커밋을 통해 수정사항을 변경했습니다.

- [x]  **오류를 찾을 때 출력 함수 대신 디버거를 사용한다**

`System.out.print()` 대신 IDE의 디버깅 도구를 사용하여 오류를 추적했습니다.

- [x]  **이름을 통해 의도를 드러낸다**

변수, 메서드, 클래스 이름을 통해 역할과 의도를 명확히 표현했습니다.

- [x]  **축약하지 않는다**

변수나 메서드 이름에 의미를 드러낼 수 있도록 축약어를 사용하지 않았습니다.

- [x]  **공백도 코딩 컨벤션이다**

if, for, while 구문 사이에 공백을 적절히 사용해 가독성을 높였습니다.

- [x]  **공백 라인을 의미 있게 사용한다**

문맥을 분리할 때 의미 있는 위치에 공백 라인을 추가했습니다.

- [x]  **스페이스와 탭을 혼용하지 않는다**

일관된 코드 스타일을 유지하기 위해 tab만 사용하여 들여쓰기를 통일했습니다.

- [x]  **의미 없는 주석을 달지 않는다**

의미를 충분히 드러낼 수 있는 경우 불필요한 주석은 생략하고, 필요한 주석만 추가했습니다.

- [x]  **코드 포매팅을 사용한다**

코드 포매팅을 통해 일관성을 유지했습니다. (IntelliJ의 자동 정렬 기능 사용)

- [x]  **Java에서 제공하는 API를 적극 활용한다**

`String.join()`과 같은 Java API (`java.util.List`)를 사용해 코드의 간결성과 효율성을 높였습니다.

- [x]  **배열 대신 컬렉션을 사용한다**

`List`와 같은 컬렉션을 사용해 데이터 관리가 용이하도록 했습니다.